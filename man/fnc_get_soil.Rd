% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fnc_get_soil.R
\name{fnc_get_soil}
\alias{fnc_get_soil}
\title{Soil-list creation}
\usage{
fnc_get_soil(
  df.ids,
  soil_option,
  PTF_to_use,
  df.soils = NULL,
  limit_MvG = T,
  add_BodenInfo = T,
  incl_GEOLA = T,
  parallel_processing = F,
  bze_buffer = 12,
  meta.out = NA,
  limit_bodtief = NA,
  force_reg_rootsdepth = F,
  maxcores = NA,
  ...
)
}
\arguments{
\item{df.ids}{either a data frame containing the following columns:
\itemize{
\item \code{ID_custom} - a unique ID-column for assignment that all intermediate products as well as the output will be assigned to.
\item \code{easting} and \code{northing} - coordinates in UTM EPSG:32632
} \cr OR: A simple feature with at the ID_custom-column. If df.ids is a simple feature, the polygon's centroids will be intersected with the Standortskartierung. A merging of information of partial coverage fractions of different STOK-polygons is not supported. So it is recommended to only use STOKA-Data as polygon-input layers, or to only use polygons that are small enough for the intersection process to not be an issue.}

\item{soil_option}{whether regionalised BZE, STOK Leitprofil data (\code{BZE}), or own data should be used for modelling. While option \code{BZE} with a buffer of 50 shouldn't create many NAs. \cr With option \code{OWN}, inusers can enter their own soil data (i.e. from lab or field experiments). If the option \code{OWN} is selected, the dataframes must be passed at \code{df.soils}.}

\item{PTF_to_use}{the PTF to be used in the modeling process. Options are \code{HYPRES}, \code{PTFPUH2}, or \code{WESSOLEK}. Alternatively, if MvG parameters have been retrieved elsewhere (i.e. by lab analyses), \code{OWN_PARMS} can be selected to skip this.}

\item{df.soils}{if \code{OWN} is selected at soil_option, a data frame must be provided here with data for each point or polygon in df.ids. The following columns are necessary:
\itemize{
\item \code{ID_custom} - a unique ID matching the IDs of df.ids
\item \code{mat} - number of soil layer starting with 1 counting upwards
\item \code{upper} and \code{lower} - upper and lower boundaries of soil layers in cm
\item \code{humus} - thickness of the humuslayer in m
\item \code{gravel} - gravel content in volumetric percent
\item \code{bd} - bulk density of fine earth in g/cmÂ³ (not needed if PTF = "WESSOLEK")
\item \code{oc.pct} - organic carbon content in mass percent
\item \code{sand} - sand content in volumetric percent
\item \code{silt} - silt content in volumetric percent
\item \code{clay} - clay content in volumetric percent
\item \code{texture} - optional - either texture or sand/silt/clay-percentages are needed

}

Caution:\cr
If PTFs are to be applied, the columns required in \code{\link{fnc_PTF}} must be provided. Else, if \code{PTF_to_use} is set to \code{OWN_PARMS}, the following columns must be provided NA-free: \code{ths, thr, alpha, npar, mpar, ksat}, and \code{tort}.\cr
If roots are to be calculated, the columns required in \code{\link{fnc_roots}} must be provided. Otherwise they need to be stored in a column called \code{rootden}.\cr
If the nFK shall be calculated at some point, this will be done for the first 1m depth, so in this case one of the layers should end at 100cm depth.}

\item{limit_MvG}{should the hydraulic parameters limited to "reasonable" ranges as described in \code{\link{fnc_limit}}. Default is \code{FALSE}.}

\item{add_BodenInfo}{shall further soil info (nFK, PWP, FK, texture ...) be added to the soil-df, default is \code{TRUE}}

\item{incl_GEOLA}{information from the \emph{Geowissenschaftliche Landesaufnahme} will be used to get additional data on soil depth and max root depth. On top of that,  \emph{Standortskartierung} and  \emph{GEOLA} will be used for identifying soil types that will be modelled differently to include the effect of groundwater (Gleye / Auenboeden) or alternating Saturation (Stauwasserboeden). Default is \code{TRUE}}

\item{parallel_processing}{the lists of dataframes are processed several times (adding roots, adding nFK information etc.). Default is \code{F} and runs with normal \code{lapply} statements. If many points are modelled, it is advised to set this to \code{T}, to activate parallel processing on several cores (as many as available). A BZE-based testrun with 32 GB RAM and 8 cores revealed a higher performance of parallel processing starting at the threshold of 250 points.}

\item{bze_buffer}{whether buffer should be used in extracting points from BZE raster files if \code{NAs} occur in {m}, default is \code{12}, because that way only the closest of the 25m raster cells gets found and we don't get multiple points from the same cell}

\item{limit_bodtief}{max soil depth, default is \code{NA} and uses max soil depth as defined in \code{df.LEIT}, \code{BZE} or the GEOLA-dataset. If not \code{NA}, soil-dfs are created down to the depth specified here as depth in \code{m}, negative}

\item{force_reg_rootsdepth}{there is a regionalised max-rootdepth, that takes into account certain soil conditions. However, it reduces the soil depth with roots significantly. Hence, by default, it is deactivated. If set to \code{T}, it will limit the lower roots depth to the regionalised values.
#' @param meta.out if \code{soil_option = "BZE"} and \code{bze_buffer != NA}, this is a way to save the meta-information of the buffering process. \code{meta.out} must be a path to a .csv-file, where for each point the coordinates and distance of the buffered cell will be stored.}

\item{maxcores}{when using a computer with multiple cores and \code{parallel_processing = T}, too many busy cores will kill the process because it creates too much data for the RAM. For 32GB RAM a maximum of 30 cores are recommended (when no other applications are open).}

\item{...}{further function arguments to be passed down to \code{\link{fnc_roots}}. Includes all adjustment options to be found in \code{\link[LWFBrook90R]{make_rootden}}. \cr Only exception is the roots functions' parameter \code{maxrootdepth}, which, if desired, has to be specified here as  \code{roots_max}, because maximal root depth setting according to vegetation parameters will be complemented by root limitations from soil conditions. \cr Settings can be either single values, applied to all soil data frames equally, or vector with the same length as \code{df.ids} specifying the roots setting for each modelling point. see example. If roots are counted and provided in \code{df.soils} as column \code{rootden}, set to \code{table}.}
}
\value{
Returns a list of soil data frames completely processed to be further used by \code{\link[LWFBrook90R]{run_multisite_LWFB90}} or \code{\link[LWFBrook90R]{run_LWFB90}}
}
\description{
This function is a wrapper of several functions and chunks of code and the main point of access for the final user. It takes a dataframe of coordinates of the points to be modeled and returns a list of soil data frames as required by \code{LWFBrook90R}. Adjustment options exist for the origin of soil data, the PTF to be used, whether MvG-parameters should be limited to a certain range, as well as all options for roots included in \code{\link[LWFBrook90R]{make_rootden}} and \code{\link{fnc_roots}} that can be passed down from here.
}
\examples{
# STOK based, filled with BZE if STOK unavaioable
fnc_get_soil(df.ids = test.ids.bds,
             soil_option = "STOK_BZE",
             PTF_to_use = "HYPRES",
             rootsmethod = "hartmann")

# same example, but with a uniform depth of 2m
fnc_get_soil(df.ids = test.ids.bds,
             soil_option = "STOK_BZE",
             PTF_to_use = "HYPRES",
             rootsmethod = "hartmann",
             limit_bodtief = -2)

# roots methods can be set individually
fnc_get_soil(df.ids = test.ids.bds,
             soil_option = "BZE",
             PTF_to_use = "HYPRES",
             rootsmethod = "betamodel",
             limit_bodtief = -2,

             maxrootdepth = c(-1, -2, -1, -2, -0.5),
             beta = 0.98)


# points in gaps of STOK-maps are not modelled
fnc_get_soil(df.ids = test.ids.bds,
                soil_option = "STOK",
                PTF_to_use = "HYPRES",
                rootsmethod = "betamodel",
                beta = 0.95)


# sample data frame with "own" data
df.own.test <- data.frame("ID_custom" = c(rep("E",4), rep("D",4), rep("C",4), rep("B",4), rep("A",4)),
                          "mat" = rep(1:4, 5),
                          "upper" = c(0,5,10,30, 0,10,50,60, 0,5,10,30, 0,10,50,60, 0,15,20,70),
                          "lower" = c(5,10,30,60, 10,50,60,100, 5,10,30,60, 10,50,60,100, 15,20,70,100),
                          "sand" = rep(30, 20),
                          "silt" = rep(40, 20),
                          "clay" = rep(30, 20),
                          "oc.pct" = c(5,2,1,0,4,1,0,0, 5,2,1,0,4,1,0,0,8,2,0,0),
                          "bd" = c(1.1,1.2,1.4,1.5,1,1.2, 1.2, 1.3, 1.1,1.2,1.4,1.5,1,1.2, 1.2, 1.3, 1.1,1.4, 1.6, 1.6 ),
                          "gravel" = c(1,5,5,20, 0,0,10,15, 5,8,8,10, 20,20,25,60,0,0,0,0) ,
                          "humus" = c(rep(0.04,4), rep(0.06, 4), rep(0.04,4), rep(0.1, 4), rep(0.05, 4)))

fnc_get_soil(df.ids = test.ids.bds,
                soil_option = "OWN",
                PTF_to_use = "HYPRES",
                df.soils = df.own.test,
                rootsmethod = "betamodel",
                beta = 0.95)


# perforremance test
df.ids <- readRDS("H:/FVA-Projekte/P01540_WHHKW/Daten/Ergebnisse/Modellierung_BW/input_data/ids_master_tr_1.rds") \%>\%
  mutate(id_standard = paste0(easting, northing),
         tranche = fnc_relateCoords(.)$tranche)
for(i in c(10,50,250, 1000, 5000, 10000)){
  tic(paste0(i, " STOK Punkte ohne Parallel:"))
  test <- fnc_get_soil(df.ids = df.ids[1:i,],
                       soil_option = "BZE",
                       PTF_to_use = "HYPRES",
                       parallel_processing = F)
  toc(log = T)
  log.txt <- tic.log(format = TRUE)
  tic.clearlog()

  write(log.txt[[1]],
        file = "H:/FVA-Projekte/P01540_WHHKW/Programme/Eigenentwicklung/paketanwendung/time.txt",
        append=TRUE)
  rm(log.txt)

  tic(paste0(i, " STOK Punkte mit Parallel:"))
  test2 <- fnc_get_soil(df.ids = df.ids[1:i,],
                       soil_option = "STOK",
                       PTF_to_use = "HYPRES",
                       parallel_processing = T)
  all.equal(test, test2)
  toc(log = T)

  log.txt <- tic.log(format = TRUE)
  tic.clearlog()

  write(log.txt[[1]],
        file = "H:/FVA-Projekte/P01540_WHHKW/Programme/Eigenentwicklung/paketanwendung/time.txt",
        append=TRUE)
  rm(log.txt)
}

}
